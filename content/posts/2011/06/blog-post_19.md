Title: Вызов функции - какова цена?
Author: d.rey
Date: 2011-06-19 05:34:00
Slug: blog-post_19
Tags: performance,pyflowctrl,python

Всего несколько постов назад поднимался [вопрос производительности pyflowctrl](http://devel.ownport.net/2011/06/pyflowctrl.html). Тогда удалось увеличить производительность почти в два раза, путем оптимизации передачи значений между процессами. Но не смотря на это, если сравнивать результат работы с эталонным значением, отрыв достаточно велик: 0.68 секунд против 6.5 секунд. Стоит разобраться на что расходуется время выполнения.

Если обобщить разницу между эталонным кодом и кодом, использующим pyflowctrl, можно сказать, что разница заключается в том, что каждая операция представлена в виде отдельного процесса. 

Код: 

    :::python
    for i in xrange(10**6):
       print i + 100,
       
представлен как генератор целых чисел, процесс для добавления 100, процесс для вывода результата на экран

![](http://2.bp.blogspot.com/-ghqwF8t_K-U/TeiCL1aAnhI/AAAAAAAAAVo/CQkff-zoJFM/s1600/pyflowctrl-example.png)

За полный цикл формируется значение, добавляется 100 и результат выводится на экран, затем цикл повторяется. Циклы выполнения можно представить в виде диаграммы вложенных функций.

![](http://2.bp.blogspot.com/-_2tOFp2XKS4/Tfz-epOJIwI/AAAAAAAAAW4/k7q0hEgZ-N0/s1600/pyflowctrl.deep_funcs.png)

Как видно из диаграммы при выполнении программы с использованием библиотеки pyflowctrl в течении каждого цикла происходит большое число вызовов функций для каждого процесса. Подключив профайлер, можно оценить время затраченное на работу каждой функции. 

![](http://3.bp.blogspot.com/-VuDuVYfDCS0/Tfz-rQdna-I/AAAAAAAAAXA/1PKFg9DYTRc/s1600/1mln_steps.png)

Уже в первых двух строках видно, что разница между суммарным временем выполнения ProcessFlow.run() и Process.run_once() отличается на 18%. Код ProcessFlow.run() не такой и сложный, чтобы на него тратился такой процент общего времени выполнения. 

    :::python
    def run(self):
        ''' run flow '''
        total_procs = len(self.pmap)
        stopped_procs = 0
        while True:
               if stopped_procs == total_procs:
                       break
               for i in self.pmap:
                       if self.pmap[i] is None:
                               continue
                       try:
                           self.pmap[i].run_once()              
                       except StopIteration:
                           self.pmap[i] = None
                           stopped_procs += 1
                       except EmptyStream:
                           pass

Каждый процесс выполняет только одну итерацию self.pmap[i].run_once() и передает результаты через потоки в другие процессы. Дело в том, что в выбранном примере, задачи, которые выполняет каждый процесс, достаточно простые и выполняются достаточно быстро. Из-за этого время вызова методов с учетом большого числа итераций так сказывается на общей длительности выполнения. В качестве практического подтверждения, изменим код каждого процесса таким образом, чтобы обработка всех данных процесса выполнялась за один цикл. В итоге получаем следующие:

![](http://3.bp.blogspot.com/-7pjVcKfLYAE/Tfz_RMysl6I/AAAAAAAAAXI/phRXkVK61GY/s1600/1_step.png)

Сразу видно, общее время выполнения сократилось в 3 раза. Если отключить профайлер и замерить время выполнения скрипта, получим 

    :::text
    $ time python examples/example6.py > /dev/null
    
    real    0m2.899s
    user    0m2.820s
    sys     0m0.070s

Данный показатель в 4 раза медленнее эталонного, но в 2 раза быстрее [предыдущей версии](http://devel.ownport.net/2011/06/pyflowctrl.html). Этот прием не является универсальным, а в некоторых случаях может быть просто не применим. Тем не менее, выбирая количество итераций выполняемых за цикл, можно контролировать скорость выполнения приложения для каждого конкретного случая.

Код скрипта используемого в качестве примера доступен в репозитории [pyflowctrl](http://code.google.com/p/sources-ownport/source/browse/pyflowctrl/examples/example6.py)

