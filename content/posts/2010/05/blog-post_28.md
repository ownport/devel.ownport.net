Title: Простой сервер приложений
Author: d.rey
Date: 2010-05-28 10:14:00
Slug: blog-post_28
Tags: server,http,application,python

В Интернете можно найти невероятное количество фреймворков и заготовок для сервера приложений. Но все они либо сложны и велики по размерам, либо требуют дополнительных сторонних библиотек, либо работают в только под unix-подобными операционными системами. Да и разработаны они по большей части для web приложений. Пару дней назад мне понадобился простой сервер приложений для реализации небольшого сетевого сервиса. Потратив несколько часов в относительно безрезультатных поисках, принял решение написать простой сервер приложений самостоятельно. 

Исходник доступен в репозитории [sources-ownport](http://code.google.com/p/sources-ownport/source/browse/parallel/libs/appserver.py). Мне очень нравится код, длина которого не превышает 100-200 строк, но который при своем небольшом размере, является законченными, функциональным приложением. Такой код легко поддерживать, легко вспомнить спустя время как же он все-таки работает :)

Сервер крайне прост. Клиент делает GET или POST запрос на сервер и получает результат в JSON формате. Логика строится на основании списка шаблонов, представленных в виде регулярных выражений и соответствующим им функциям. Определяется по аналогии с [django](http://djangoproject.org) переменной url_patterns. Важный момент: для передачи переменных в функцию необходимо использовать именованные переменные (?P<var_name>). 

Например:

    :::python
    url_patterns = (
        (r'/(?P<object_type>)/get/(?P<object_id>)/', get_object),
    )

В приведенном примере, для запрашиваемого URL _http://localhost:8080/person/get/123/_  будет вызвана функция get_object и переданы переменные в виде словаря _{ 'object_type': 'person', 'object_id': '123' }_

Все функции должны возвращать словарь значений, так как сервер обрабатывает этот словарь и возвращает результат клиенту в json формате.

Одной из причин, кроме простоты, почему я написал этот сервер, была необходимость в использовании нескольких потоков или процессов при обработке функций. Выбор режима работы сервера определяется с помощью передачи параметра server_type при вызове сервера, например:

    :::python
    appserver.run_server(port=8081,server_type=appserver.THREADED_SERVER)

Переменная server_type может приниматься в настоящий момент два значения: THREADED_SERVER для использования потоков и FORKED_SERVER для использования процессов

Следует предостеречь, что у данного сервера совершенно нет защиты от внешнего воздействия. Т.е. доступ к данным сервера могут получить все, кто может сделать хотя бы пинг на этот хост. Поэтому его следует запускать только в доверительных сетях.

В своем следующем посте я приведу пример реально работающего приложения на базе этого сервера - TQueueSrv (Очередь задач). Это маленький сервис выполняющий функции аналогичные [Queue ](http://docs.python.org/library/queue.html)из стандартной библиотеки python, только с возможностью получать доступ к задачам через сеть, позволяя тем самым разнести задачи многопоточности между несколькими хостами.

